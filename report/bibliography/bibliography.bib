@book{farber2011cuda,
  title={CUDA application design and development},
  author={Farber, Rob},
  year={2011},
  publisher={Elsevier}
}
@inproceedings{ieee_voc_2010,
  title = {{Systems and Software Engineering -- Vocabulary}},
  booktitle = {ISO/IEC/IEEE 24765},
  author = {ISO and IEC and IEEE},
  language={English},
  publisher = {IEEE},
  pages = {1-418},
  year = {2010},
  isbn = {9780738162058},
  abstract = {The systems and software engineering disciplines are continuing to mature while information technology advances. This International Standard was prepared to collect and standardize terminology. Its purpose is to identify terms currently in use in the field and standard definitions for these terms. It is intended to serve as a useful reference for those in the Information Technology field, and to encourage the use of systems and software engineering standards prepared by ISO and liaison organizations IEEE Computer Society and Project Management Institute (PMI). This International Standard replaces IEEE Std 610.12-1990, IEEE Standard Glossary of Software Engineering Terminology, which was contributed by the IEEE as a source document. The approach and lexical exactitude of IEEE Std 610.12-1990 served as a model for this International Standard. Nevertheless, approximately two thirds of the definitions in this International Standard are new since IEEE Std 610.12 was last updated in 1990, a reflection of the continued evolution in the field.},
  doi = {10.1109/IEEESTD.2010.5733835}
}
@article{diffie1976a,
  title = {{New Directions in Cryptography}},
  language={English},
  publisher = {IEEE},
  author = {Diffie, W. and Hellman, ME},
  journal = {Information Theory, IEEE Transactions on},
  volume = {22},
  number = {6},
  pages = {644-654},
  year = {1976},
  issn = {00189448},
  abstract = {Two kinds of contemporary developments in cryptography are examined. Widening applications of teleprocessing have given rise to a need for new types of cryptographic systems, which minimize the need for secure key distribution channels and supply the equivalent of a written signature. This paper suggests ways to solve these currently open problems. It also discusses how the theories of communication and computation are beginning to provide the tools to solve cryptographic problems of long standing.},
  doi = {10.1109/TIT.1976.1055638}
}
@article{Fowler1999,
abstract = {As the application of object technology-particularly the Java programming language-has become commonplace, a new problem has emerged to confront the software development community. Significant numbers of poorly designed programs have been created by less-experienced developers, resulting in applications that are inefficient and hard to maintain and extend. Increasingly, software system professionals are discovering just how difficult it is to work with these inherited, "non-optimal" applications. For several years, expert-level object programmers have employed a growing collection of techniques to improve the structural integrity and performance of such existing software programs. Referred to as "refactoring," these practices have remained in the domain of experts because no attempt has been made to transcribe the lore into a form that all developers could use. . .until now. In Refactoring: Improving the Design of Existing Software, renowned object technology mentor Martin Fowler breaks new ground, demystifying these master practices and demonstrating how software practitioners can realize the significant benefits of this new process. With proper training a skilled system designer can take a bad design and rework it into well-designed, robust code. In this book, Martin Fowler shows you where opportunities for refactoring typically can be found, and how to go about reworking a bad design into a good one. Each refactoring step is simple-seemingly too simple to be worth doing. Refactoring may involve moving a field from one class to another, or pulling some code out of a method to turn it into its own method, or even pushing some code up or down a hierarchy. While these individual steps may seem elementary, the cumulative effect of such small changes can radically improve the design. Refactoring is a proven way to prevent software decay. In addition to discussing the various techniques of refactoring, Refactoring: Improving the Design of Existing Software provides a detailed catalog of more than seventy proven refactorings with helpful pointers that teach you when to apply them; step-by-step instructions for applying each refactoring; and an example illustrating how the refactoring works. The illustrative examples are written in Java, but the ideas are applicable to any object-oriented programming language.},
author = {Fowler, Martin and Beck, Kent and Brant, John and Opdyke, William and Roberts, Don},
doi = {10.1007/s10071-009-0219-y},
isbn = {9780201485677},
issn = {14359456},
journal = {Xtemp01},
pages = {1--337},
pmid = {19263100},
title = {{Refactoring: Improving the Design of Existing Code}},
year = {1999}
}
@book{Canfora2014,
abstract = {Context Software systems continuously change for various reasons, such as adding new features, fixing bugs, or refactoring. Changes may either increase the source code complexity and disorganization, or help to reducing it. Aim This paper empirically investigates the relationship of source code complexity and disorganization—measured using source code change entropy—with four factors, namely the presence of refactoring activities, the number of developers working on a source code file, the participation of classes in design patterns, and the different kinds of changes occurring on the system, classified in terms of their topics extracted from commit notes. Method We carried out an exploratory study on an interval of the life-time span of four open source systems, namely ArgoUML, Eclipse-JDT, Mozilla, and Samba, with the aim of analyzing the relationship between the source code change entropy and four factors: refactoring activities, number of contributors for a file, participation of classes in design patterns, and change topics. Results The study shows that (i) the change entropy decreases after refactoring, (ii) files changed by a higher number of developers tend to exhibit a higher change entropy than others, (iii) classes participating in certain design patterns exhibit a higher change entropy than others, and (iv) changes related to different topics exhibit different change entropy, for example bug fixings exhibit a limited change entropy while changes introducing new features exhibit a high change entropy. Conclusions Results provided in this paper indicate that the nature of changes (in particular changes related to refactorings), the software design, and the number of active developers are factors related to change entropy. Our findings contribute to understand the software aging phenomenon and are preliminary to identifying better ways to contrast it.},
author = {Canfora, Gerardo and Cerulo, Luigi and Cimitile, Marta and {Di Penta}, Massimiliano},
booktitle = {Empirical Software Engineering},
doi = {10.1007/s10664-012-9214-z},
file = {:Users/petur/Documents/Mendeley Desktop/Canfora et al. - 2014 - How changes affect software entropy An empirical study.pdf:pdf},
isbn = {1066401292},
issn = {13823256},
keywords = {Mining software repositories,Software complexity,Software entropy},
mendeley-groups = {Robust/Report},
pages = {1--38},
title = {{How changes affect software entropy: An empirical study}},
volume = {19},
year = {2014}
}
@article{Yourdon1995,
abstract = {\&amp;ldquo;You can get it fast; you can have it cheap; you can get it
right. Pick two\&amp;rdquo;. That sign could be displayed on the wall of
every software development organization; and yet most of our customers
want all three. The author tackles this dilemma. He contends that we
don't rationally establish a proper balance among the critical project
parameters: cost, schedule, staffing, functionality and quality. Our
customers want us to optimize all these parameters, even when this is
clearly impossible},
author = {Yourdon, E.},
doi = {10.1109/52.382191},
file = {:Users/petur/Documents/Mendeley Desktop/Yourdon - 1995 - When good enough software is best.pdf:pdf},
issn = {0740-7459},
journal = {IEEE Software},
mendeley-groups = {Robust,Robust/Report},
pages = {79--81},
title = {{When good enough software is best}},
volume = {12},
year = {1995}
}
@book{jacobson1992a,
  title = {Object-oriented software engineering. A use case driven approach},
  publisher = {Addison-Wesley Publ},
  author = {Jacobson, I. and Christerson, M. and Jonsson, P. and \"{O}vergaard, G.},
  pages = {524 s},
  year = {1992}
}
@article{Lehman1984,
abstract = {Following a brief review of the development of the concept of program evolution, the paper identifies some of the program attributes that are changed over system life-time in response to evolutionary pressures. It recognises that their evolution may, in part, be due to inadequate specification, design and implementation technologies; the processes by which a system is conceived and implemented, and the primitives in terms of which this is done. Basically, however, evolution is recognised as intrinsic to the very nature of computer application, of computing systems, and, most significantly, of programs. All systems evolve. The peculiar feature of computing systems is their rate of evolution. Analysis of this phenomenon leads to the identification of levels of evolutionary development; thence to the concept of a continuous programming process supported by an integrated support environment. One model of such a process is outlined and then decomposed into a sequence of orthogonal elements or steps that can all be described by a common paradigm. The former provides a conceptual framework for the design of integrated support environments, the latter its core concept.},
author = {Lehman, M.M.},
doi = {10.1016/0306-4573(84)90037-2},
file = {:Users/petur/Documents/Mendeley Desktop/Lehman - 1984 - Program evolution.pdf:pdf},
isbn = {0306-4573},
issn = {03064573},
journal = {Information Processing \& Management},
mendeley-groups = {Robust,Robust/Report},
pages = {19--36},
title = {{Program evolution}},
volume = {20},
year = {1984}
}
@article{lehman1979a,
  title = {On understanding laws, evolution, and conservation in the large-program life cycle},
  language = {English},
  author = {Lehman, M.M.},
  journal = {Journal of Systems and Software},
  volume = {1},
  pages = {213-221},
  year = {1979},
  issn = {01641212},
  abstract = {The paper presents interpretations of some recently discovered laws of evolution and conservation in the largeprogram life cycle. Program development and maintenance processes are managed and implemented by people; thus in the long term they could be expected to be unpredictable, dependant on the judgments, whims, and actions of programming process participants (e.g., managers, programmers, and product users). Yet, observed, measured, and modeled regularities suggest laws that are closer to biological laws or those of modern physics than to those currently formulated in other areas subject to human influence (e.g., economics and sociology). After a brief discussion of the first four laws, to highlight underlying phenomena and natural attributes of the program evolution process, the paper concentrates on a fifth law and shows how, and why, this law represents a conservation phenomenon: the Conservation of Familiarity.}
}
@book{meyer1988object,
  title={Object-oriented software construction},
  author={Meyer, Bertrand},
  volume={2},
  year={1988},
  publisher={Prentice hall New York}
}
@misc{android,
  title={{Android Open Source Project}},
  howpublished={\url{http://android.github.io/}},
  note={github repo used: \url{https://github.com/android/platform_frameworks_base}}
}
@article{Heemstra1992a,
author = {Heemstra, F.J.},
doi = {10.1016/0950-5849(92)90068-Z},
file = {:Users/petur/Library/Application Support/Mendeley Desktop/Downloaded/Heemstra - 1992 - Software cost estimation.pdf:pdf},
issn = {09505849},
journal = {Information and Software Technology},
mendeley-groups = {Papers},
month = oct,
number = {10},
pages = {627--639},
title = {{Software cost estimation}},
url = {http://linkinghub.elsevier.com/retrieve/pii/095058499290068Z},
volume = {34},
year = {1992}
}
@article{Boehm1984,
abstract = {This paper summarizes the current state of the art and recent trends in software engineering economics. It provides an overview of economic analysis techniques and their applicability to software engineering and management. It surveys the field of software cost estimation, including the major estimation techniques available, the state of the art in algorithmic cost models, and the outstanding research issues in software cost estimation.},
author = {Boehm, B W},
doi = {10.1109/TSE.1984.5010193},
file = {:Users/petur/Downloads/05010193.pdf:pdf},
isbn = {0138221227},
issn = {0098-5589},
journal = {Software Engineering, IEEE Transactions on},
keywords = {Analytical models,Computer programming costs,Costs,Engineering management,Life estimation,Microeconomics,Power generation economics,Resource management,Software prototyping,State estimation,cost models,management decision aids,software cost estimation,software economics,software engineering,software management},
number = {1},
pages = {4--21},
title = {{Software Engineering Economics}},
url = {http://ieeexplore.ieee.org/lpdocs/epic03/wrapper.htm?arnumber=5010193},
volume = {SE-10},
year = {1984}
}
@book{fischer2009crafting,
  title={Crafting a compiler},
  author={Fischer, Charles N and Cytron, Ronald K and LeBlanc, Richard J},
  year={2009},
  publisher={Addison-Wesley Publishing Company}
}
@misc{antlr,
  title={{ANTLR}},
  howpublished={\url{http://www.antlr.org/}},
  url={http://www.antlr.org/},
  year={2015},
  month={April},
  note={visited April 10, 2015}
}
@book{nielson2015principles,
  title={Principles of program analysis},
  author={Nielson, Flemming and Nielson, Hanne R and Hankin, Chris},
  edition={2nd},
  year={2015},
  publisher={Springer}
}
